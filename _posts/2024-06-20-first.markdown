---
layout: post
title: first
date: 2024年06月20日 18:11:25
---

# 配置环境

## Cmake 入门(bushi)

在Linux平台下使用Cmake生成Makefile并编译的流程如下：

- 编写Cmake配置文件CmakeLists.txt
- 执行命令Cmake PATH 或者 ccmake PATH 生成 Makefile。 其中， PATH是CMakeLists.txt 所在的目录。
- 使用 make 命令进行编译。



### 入门案例：单个源文件

main.cc

```c
#include <stdio.h>
#include <stdlib.h>
/**
 * power - Calculate the power of number.
 * @param base: Base value.
 * @param exponent: Exponent value.
 *
 * @return base raised to the power exponent.
 */
double power(double base, int exponent)
{
  int result = base;
  int i;
  
  if (exponent == 0) {
    return 1;
  }
  
  for(i = 1; i < exponent; ++i){
    result = result * base;
  }
  return result;
}
int main(int argc, char *argv[])
{
  if (argc < 3){
    printf("Usage: %s base exponent \n", argv[0]);
    return 1;
  }
  double base = atof(argv[1]);
  int exponent = atoi(argv[2]);
  double result = power(base, exponent);
  printf("%g ^ %d is %g\n", base, exponent, result);
  return 0;
}

```

- 编写`CMakeLists.txt`

  ```cmake
  # CMake 最低版本要求
  cmake_minimum_required(VERSION 2.8)
  # 项目信息
  project(Deom1)
  #指定生成目标
  add_executable(Demo main.cc)
  ```

- 编译项目

  - 在当前目录执行`cmake . ` 得到Makefile后再使用 make 命令编译得到 Demo1可执行文件
  - 再VScode中，需要安装cmake插件，`ctrl shift p `，找的cmake configure，指定gcc等编译器，然后进入 bulid 目录， 最后执行 `cmake `(linux)  `mingw32-make.exe`(windows).然后就能获得 Demo1可执行文件了



### 多个源文件

> 示例：Demo2

目录结构：

```
./Demo2
    |
    +--- main.cc
    |
    +--- MathFunctions.cc
    |
    +--- MathFunctions.h
```



对应CMakeLists.txt的内容：

```cmake
# CMake 最低版本号要求
cmake_minimum_required (VERSION 2.8)
# 项目信息
project (Demo2)
# 指定生成目标
add_executable(Demo main.cc MathFunctions.cc)
```

唯一的改动只是在 add_executable 命令中增加了一个 MathFunctions.cc 源文件。

更省事的方法是使用 `aux_source_directory`命令，该方法会查找指定目录下的所有源文件，然后将结果存进指定变量名。其语法如下

```cmake
aux_source_directory(<dir> <variable>)
```

使用此命令，对应CMakeLists.txt

```cmake
# CMake 最低版本号要求
cmake_minimum_required (VERSION 2.8)
# 项目信息
project (Demo2)
# 查找当前目录下的所有源文件
# 并将名称保存到 DIR_SRCS 变量
aux_source_directory(. DIR_SRCS)
# 指定生成目标
add_executable(Demo ${DIR_SRCS})
```



### 多个目录， 多个源文件

> Demo3

```
./Demo3
    |
    +--- main.cc
    |
    +--- math/
          |
          +--- MathFunctions.cc
          |
          +--- MathFunctions.h
```

根目录中的CMakeLists.txt

```cmake
project (Demo3)
# 查找当前目录下的所有源文件
# 并将名称保存到 DIR_SRCS 变量
aux_source_directory(. DIR_SRCS)
# 添加 math 子目录
add_subdirectory(math)
# 指定生成目标
add_executable(Demo main.cc)
# 添加链接库
target_link_libraries(Demo MathFunctions)
```

子目录中的CMakeLists.txt

```cmake
# 查找当前目录下的所有源文件
# 并将名称保存到 DIR_LIB_SRCS 变量
aux_source_directory(. DIR_LIB_SRCS)
# 生成链接库
add_library (MathFunctions ${DIR_LIB_SRCS})
```



## Makefile模板

> 小白想了几个小时，主要是必要的知识不知道或者忘记了
>
> ```makefile
> VERSION  =1.00
> CC   =gcc
> DEBUG   = 1
> CFLAGS  =-Wall -Og -fdiagnostics-color=always
> 
> BUILD_DIR = build
> OUTPUT = output
> 
> ifeq ($(DEBUG), 1)
> CFLAGS += -g -gdwarf-2 
> endif
> 
> # FileSearch = $(foreach d, $(wildcard $1*), $(call rwildcard,$d/,$2) $(filter $2, $d))
> # 示例：搜索LVGL_PATH下的所有.c文件，并将其路径(包含文件名)保存到LVGLC
> # LVGLC := $(call rwildcard, $(LVGL_PATH), %.c)  
> 
> C_SOURCES =  \
> $(wildcard ./src/*.c)
> 
> 
> C_INCLUDES = \
> -Iinc
> 
> 
> CFLAGS += $(C_INCLUDES)
> CFLAGS += -MMD -MP -MF"$(@:%.o=%.d)"
> 
> LIB_NAMES  = 
> LIB_PATH  = -Llib
> 
> 
> OBJECTS = $(addprefix $(BUILD_DIR)/,$(notdir $(patsubst %.c, %.o, $(C_SOURCES))))
> DEPENDS = $(patsubst %.o, %.d, $(OBJECTS))
> vpath %.c $(sort $(dir $(C_SOURCES)))
> 
> 
> TARGET  = test
> 
> $(TARGET): $(OBJECTS)  | MKDIR
> 	$(CC) $(OBJECTS) $(LIB_PATH) $(LIB_NAMES) -o $(OUTPUT)/$(TARGET).exe
> 
> $(BUILD_DIR)/%.o: %.c Makefile | MKDIR
> 	$(CC) -c $(CFLAGS) -Wa,-a,-ad,-alms=$(BUILD_DIR)/$(notdir $(<:.c=.lst)) $< -o $@
> 
> 
> 
> .PHONY:clean
> 
> MKDIR:
> 	$(shell if [ ! -e $(OUTPUT) ];then mkdir -p $(OUTPUT); fi)
> 	$(shell if [ ! -e $(BUILD_DIR) ];then mkdir -p $(BUILD_DIR); fi)
> 
> clean:
> 	@echo "Remove linked and compiled files......"
> 	rm -rf $(BUILD_DIR)/*.o
> 	rm -rf $(OUTPUT)/*.exe
> 
> debug:
> 	@echo $(CFLAGS)
> 
> -include $(wildcard $(BUILD_DIR)/*.d)
> ```



### bug记录

1. 如果移动了一个{name}.c,{name}.h, 务必在Makefile里做对应的修改，尤其是使用了上述模板的自动搜索功能

## VSCode配置C/C++环境



### 使用Cmake

使用插件:

新建文件：`CMakeLists.txt`

输入：

```cmake
project(project_name)

add_executable(output_name main.cpp swap.cpp ...(source cpp)...)

```

然后保存，插件会自动生成目录build



#### 多目录 多文件CMakeLists.txt

> |- CMakeLists.txt
>
> |- math
>
> ​	|- \*.cc
>
> ​    |- \*.h
>
> main.cc



```cmake
project(Demo3_1)

aux_source_directory(. DIR_SRCS)
aux_source_directory(math Math_SRCS)

include_directories(math)


add_executable(main ${DIR_SRCS} ${Math_SRCS})
```





#### launch.json样例

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "C/C++: g++ build and debug active file",
      "type": "cppdbg",
      "request": "launch",
      "program": "${fileDirname}/build/${fileBasenameNoExtension}",
      "args": [],
      "stopAtEntry": false,
      "cwd": "${workspaceFolder}",
      "environment": [],
      "externalConsole": false,
      "MIMode": "gdb",
      "miDebuggerPath": "D:/Program files/mingw64/bin/gdb.exe",
      "setupCommands": [
        {
          "description": "Enable pretty-printing for gdb",
          "text": "-enable-pretty-printing",
          "ignoreFailures": true
        }
      ],
      "preLaunchTask": "Build"
    }
  ]
}
```



#### task.json样例

```json
{
    "version": "2.0.0",
    "options": {
        "cwd": "${fileDirname}/build"
    },
    "tasks": [
        {
            "type": "shell",
            "label": "cmake",
            "command": "cmake",
            "args": [
                ".."
            ]
        },
        {
            "label": "make",
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "command": "mingw32-make.exe", // :Windows  make: Linex下
            "args": []
        },
        {
            "label": "Build",
            "dependsOn": [
                "cmake",
                "make"
            ]
        }
    ],
}
```



#### lanuch.json

将`"program:"` 设置为build路径下，对应好CMakeLists.txt确定的名字



### Vscode调试C语言技巧

#### 强行显示数组

```
*arr_name@10、 *(int(*)[10])arr_name
```



# C语言笔记(电赛)

## 运算符优先级

| 优先级 | 运算符 | 名称或含义       | 使用形式                  | 结合方向   | 说明             |
| ------ | ------ | ---------------- | ------------------------- | ---------- | ---------------- |
| 1      | []     | 数组下标         | 数组名[常量表达式]        | 左到右     |                  |
|        | ()     | 圆括号           | （表达式）/函数名(形參表) |            |                  |
|        | .      | 成员选择（对象） | 对象.成员名               |            |                  |
|        | ->     | 成员选择（指针） | 对象指针->成员名          |            |                  |
| 2      | -      | 负号运算符       | -表达式                   | 右到左     | 单目运算符       |
|        | (类型) | 强制类型转换     | (数据类型)表达式          |            |                  |
|        | ++     | 自增运算符       | ++变量名/变量名++         | 单目运算符 |                  |
|        | --     | 自减运算符       | --变量名/变量名--         | 单目运算符 |                  |
|        | *      | 取值运算符       | *指针变量                 | 单目运算符 |                  |
|        | &      | 取地址运算符     | &变量名                   | 单目运算符 |                  |
|        | !      | 逻辑非运算符     | !表达式                   | 单目运算符 |                  |
|        | ~      | 按位取反运算符   | ~表达式                   | 单目运算符 |                  |
|        | sizeof | 长度运算符       | sizeof(表达式)            |            |                  |
| 3      | /      | 除               | 表达式/表达式             | 左到右     | 双目运算符       |
|        | *      | 乘               | 表达式*表达式             | 双目运算符 |                  |
|        | %      | 余数（取模）     | 整型表达式/整型表达式     | 双目运算符 |                  |
| 4      | +      | 加               | 表达式+表达式             | 左到右     | 双目运算符       |
|        | -      | 减               | 表达式-表达式             | 双目运算符 |                  |
| 5      | <<     | 左移             | 变量<<表达式              | 左到右     | 双目运算符       |
|        | >>     | 右移             | 变量>>表达式              | 双目运算符 |                  |
| 6      | >      | 大于             | 表达式>表达式             | 左到右     | 双目运算符       |
|        | >=     | 大于等于         | 表达式>=表达式            | 双目运算符 |                  |
|        | <      | 小于             | 表达式<表达式             | 双目运算符 |                  |
|        | <=     | 小于等于         | 表达式<=表达式            | 双目运算符 |                  |
| 7      | ==     | 等于             | 表达式==表达式            | 左到右     | 双目运算符       |
|        | !=     | 不等于           | 表达式!= 表达式           | 双目运算符 |                  |
| 8      | &      | 按位与           | 表达式&表达式             | 左到右     | 双目运算符       |
| 9      | ^      | 按位异或         | 表达式^表达式             | 左到右     | 双目运算符       |
| 10     | \|     | 按位或           | 表达式\|表达式            | 左到右     | 双目运算符       |
| 11     | &&     | 逻辑与           | 表达式&&表达式            | 左到右     | 双目运算符       |
| 12     | \|\|   | 逻辑或           | 表达式\|\|表达式          | 左到右     | 双目运算符       |
| 13     | ?:     | 条件运算符       | 表达式1? 表达式2: 表达式3 | 右到左     | 三目运算符       |
| 14     | =      | 赋值运算符       | 变量=表达式               | 右到左     |                  |
|        | /=     | 除后赋值         | 变量/=表达式              |            |                  |
|        | *=     | 乘后赋值         | 变量*=表达式              |            |                  |
|        | %=     | 取模后赋值       | 变量%=表达式              |            |                  |
|        | +=     | 加后赋值         | 变量+=表达式              |            |                  |
|        | -=     | 减后赋值         | 变量-=表达式              |            |                  |
|        | <<=    | 左移后赋值       | 变量<<=表达式             |            |                  |
|        | >>=    | 右移后赋值       | 变量>>=表达式             |            |                  |
|        | &=     | 按位与后赋值     | 变量&=表达式              |            |                  |
|        | ^=     | 按位异或后赋值   | 变量^=表达式              |            |                  |
|        | \|=    | 按位或后赋值     | 变量\|=表达式             |            |                  |
| 15     | ,      | 逗号运算符       | 表达式,表达式,…           | 左到右     | 从左向右顺序运算 |

## 动态分配数组

```c
#include<stdlib.h>
pd=(int*)malloc(len*sizeof(int));

free(pd);
```

## 枚举  enum

```c
enum WeekDay{Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Staurday};
```

[C语言枚举类型（C语言enum用法）详解 (biancheng.net)](http://c.biancheng.net/view/2034.html)

1）枚举的大小是按照enum中元素最大值所占的内存大小来决定的，不像结构体那样有多少个元素就按各个元素所占字节叠加。

2）当枚举成员的值小于4个字节时，占4个字节。

3）当枚举成员的值大于4个字节时，最大只能是longlong类型，占8个字节。

## 指针

![image-20211024135724668](D:\STUDY\C\CStudy.assets\image-20211024135724668-16350550466901.png)



### 函数指针

```c
int function(int a, int b)
{
    //执行代码
}
 
int main(void)
{
    int (*FP)(int, int)；
    FP= function;    //第一种赋值方法
   // FP = &function;   //第二种赋值方法
    FP(1,2);       //第一种调用方法
   // (*FP)(1,2);  //第二种调用方法
 
}
```



## 字符串

```c
#include<string.h>

char s1[];
char s2[];

strcpy(s1,s2);
// 复制字符串s2到字符串s1

strcat(s1,s2);
//连接字符串s2到s1的末尾

strlen(s1);
//返回字符串s1的长度

strcmp(s1,s2);
//如果s1和s2相同的，则返回0；如果s1<s2，则返回小于0；如果s1>s2，则返回大于0

strchar(s1,ch);
//返回一个指针，指向字符串s1中s2的第一次出现的位置

char *strstr(const char *haystack, const char *needle);
//在字符串 haystack 中查找第一次出现字符串 needle 的位置，不包含终止符 '\0'。

```

### 字符串格式化输出

C语言中格式字符串的一般形式为： % [ 标志 ] [ 输出最小宽度 ] [. 精度 ] [ 长度 ] 类型 ， 其中方括号[]中的项为可选项。

一、类型

我们用一定的字符用以表示输出数据的类型，其格式符和意义下表所示：

字符                  意义

a         浮点数、十六进制数字和p-计数法(C99)

A         浮点数、十六进制数字和p-计数法(C99)

c         输出单个字符

d         以十进制形式输出带符号整数(正数不输出符号)

e         以指数形式输出单、双精度实数

E         以指数形式输出单、双精度实数

f          以小数形式输出单、双精度实数

g         以%f%e中较短的输出宽度输出单、双精度实数,%e格式在指数小于-4或者大 于等于精度时使用

G         以%f%e中较短的输出宽度输出单、双精度实数,%e格式在指数小于-4或者大于等于精度时使用

i          有符号十进制整数(与%d相同)

o         以八进制形式输出无符号整数(不输出前缀O)

p         指针

s          输出字符串

x          以十六进制形式输出无符号整数(不输出前缀OX)

X          以十六进制形式输出无符号整数 (不输出前缀OX)

u          以十进制形式输出无符号整数



二、标志

标志字符为 - 、 + 、 # 、 空格 和 0 五种，其意义下表所示：

字符                意 义

\-            结果左对齐，右边填空格

\+            输出符号(正号或负号)

空格         输出值为正时冠以空格，为负时冠以负号

\#            对c，s，d，u类无影响；对o类，在输出时加前缀0；对x类，在输出时加前缀0x或者0X；对g，G 类防止尾随0被删除；

​            对于所有的浮点形式，#保证了即使不跟任何数字，也打印一个小数点字符

0            对于所有的数字格式，用前导0填充字段宽度，若出现-标志或者指定了精度(对于整数),忽略



三、输出最小宽度

用十进制整数来表示输出的最少位数。若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。



四、精度

精度 格式符以“.”开头，后跟十进制整数。本项的意义是： 如果输出数字，则表示小数的位数；如果输出的是字符，则表示输出字符的个数；若实际位数大于所定义的精度数，则截去超过的部分 。



五、长度

长度格式符为 h , l 两种， h 表示按短整型量输出， l 表示按长整型量输出。

h 和 整数转换说明符 一起使用，表示一个short int 或者unsigned short int类型的数值，

示例： %hu，%hx，%6.4hd

hh 和 整数转换说明符 一起使用，表示一个singed char 或者unsigned char类型的数值，

示例： %hhu，%hhx，%6.4hhd

j 和 整数转换说明符 一起使用，表示一个intmax_t或者uintmax_t类型的数值，

示例： %jd,%8jx

l 和 整数转换说明符 一起使用，表示一个long int 或者unsigned long int类型的数值，

示例： %ld,%8lu

ll 和 整数转换说明符 一起使用，表示一个long int 或者unsigned long int类型的数值(C99)，

示例： %lld,%8llu

L 和 浮点转换说明符 一起使用，表示一个long double的值，示例：%Lf，%10.4Le

t 和 整数转换说明符 一起使用，表示一个ptrdiff_t值(两个指针之间的差相对应的类型)(C99)，

示例： %td,%12ti

z 和 整数转换说明符 一起使用，表示一个size_t值(sizeof返回的类型)(C99)，

示例： %zd,%12zx



> UNICODE编码:[一文彻底搞懂Unicode编码问题 (wangwl.net)](https://wangwl.net/static/pages/unicode.html)



### 字符串正则化读取

> 成功则返回参数数目，失败则返回-1，错误原因存于errno中

```C
void sscanf_test(void)
{
	int ret;
	char *string;
	int  digit;
	char buf1[255];
	char buf2[255];
	char buf3[255];
	char buf4[255];
 
	/*1.最简单的用法*/
	string = "china beijing 123";
	ret = sscanf(string, "%s %s %d", buf1, buf2, &digit);
	printf("1.string=%s\n", string);
	printf("1.ret=%d, buf1=%s, buf2=%s, digit=%d\n\n", ret, buf1, buf2, digit);
	/*
	**执行结果:
	**1.ret=3, buf1=china, buf2=beijing, digit=123
	**可以看出,sscanf的返回值是读取的参数个数
	*/
 
	/*2.取指定长度的字符串*/
	string = "123456789";
	sscanf(string, "%5s", buf1);
	printf("2.string=%s\n", string);
	printf("2.buf1=%s\n\n", buf1);
	/*
	**执行结果:
	**2.buf1=12345
	*/
 
	/*3.取到指定字符为止的字符串*/
	string = "123/456";
	sscanf(string, "%[^/]", buf1);
	printf("3.string=%s\n", string);
	printf("3.buf1=%s\n\n", buf1);
	/*
	**执行结果:
	**3.buf1=123
	*/
 
	/*4.取到指定字符集为止的字符串*/
	string = "123abcABC";
	sscanf(string, "%[^A-Z]", buf1);
	printf("4.string=%s\n", string);
	printf("4.buf1=%s\n\n", buf1);
	/*
	**执行结果:
	**4.buf1=123abc
	*/
 
	/*5.取仅包含指定字符集的字符串*/
	string = "0123abcABC";
	sscanf(string, "%[0-9]%[a-z]%[A-Z]", buf1, buf2, buf3);
	printf("5.string=%s\n", string);
	printf("5.buf1=%s, buf2=%s, buf3=%s\n\n", buf1, buf2, buf3);
	/*
	**执行结果:
	**5.buf1=123, buf2=abc, buf3=ABC
	*/
 
	/*6.获取指定字符中间的字符串*/
	string = "ios<android>wp7";
	sscanf(string, "%*[^<]<%[^>]", buf1);
	printf("6.string=%s\n", string);
	printf("6.buf1=%s\n\n", buf1);
	/*
	**执行结果:
	**6.buf1=android
	*/
 
	/*7.指定要跳过的字符串*/
	string = "iosVSandroid";
	sscanf(string, "%[a-z]VS%[a-z]", buf1, buf2);
	printf("7.string=%s\n", string);
	printf("7.buf1=%s, buf2=%s\n\n", buf1, buf2);
	/*
	**执行结果:
	**7.buf1=ios, buf2=android
	*/
 
	/*8.分割以某字符隔开的字符串*/
	string = "android-iphone-wp7";
	/*
	**字符串取道'-'为止,后面还需要跟着分隔符'-',
	**起到过滤作用,有点类似于第7点
	*/
	sscanf(string, "%[^-]-%[^-]-%[^-]", buf1, buf2, buf3);
	printf("8.string=%s\n", string);
	printf("8.buf1=%s, buf2=%s, buf3=%s\n\n", buf1, buf2, buf3);
	/*
	**执行结果:
	**8.buf1=android, buf2=iphone, buf3=wp7
	*/
 
	/*9.提取邮箱地址*/
	string = "Email:beijing@sina.com.cn";
	sscanf(string, "%[^:]:%[^@]@%[^.].%s", buf1, buf2, buf3, buf4);
	printf("9.string=%s\n", string);
	printf("9.buf1=%s, buf2=%s, buf3=%s, buf4=%s\n\n", buf1, buf2, buf3, buf4);
	/*
	**执行结果:
	**9.buf1=Email, buf2=beijing, buf3=sina, buf4=com.cn
	*/
 
	/*10.过滤掉不想截取或不需要的字符串--补充,
	**在%号后面加一*号,代表过滤这个字符串,不读取
	*/
	string = "android iphone wp7";
	sscanf(string, "%s %*s %s", buf1, buf2);
	printf("10.string=%s\n", string);
	printf("10.buf1=%s, buf2=%s\n\n", buf1, buf2);
	/*
	**执行结果:
	**10.android wp7
	*/
}

```



#### sscanf踩坑

> [(43条消息) sscanf取值异常的问题笔记_Eric__zh的博客-CSDN博客_sscanf读取数值不对](https://blog.csdn.net/Eric__zh/article/details/110181480)

sscanf取的值按4字节写，在stm32中可能是该种原因导致访问越界导致的hardfault。

## 结构体

```c
typedef struct struct_name
{
   char name[50];
   char sno[13];

}Student, *stu;  // 没有typedef则是变量，否则是新结构名 

Student zs;  // 等价于 struct struct_name zs;
// 。。。
stu p;
p = &zs;
```



- 结构体指针

  (*指针变量名).成员名  与 指针变量名->成员名 效果相同

  

1. 默认情况下，结构体的大小是结构体中最长类型的整数倍。
2. 结构体中的空间分布是按照结构体中最长类型对齐的。
3. 结构体中不同类型的成员，一定是按照自己的类型对齐。比如，int型的起始地址一定是4的整数倍，short型的首地址一定是2的整数倍。。。

## 共用体

> 共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。
>
> union:共用一个内存首地址

```c
union Data
{
   int i;
   float f;
   char  str[20];
} data;
```

共用体占用的内存应足够存储共用体中最大的成员。例如，在上面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。

### 共用体判断系统大小端

> **大端模式(**Big-endian)，是指数据的高字节保存在内存的低地址中，而**数据的低字节保存在内存的高地址中**，这样的存储模式有点儿类似于把数据当作字符串顺序处理:地址由小向大增加，而数据从高位往低位放;
>
> **小端模式**(Little-endian)，是指数据的高字节保存在内存的高地址中，而**数据的低字节保存在内存的低地址中**，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。

```C
int checkCPUendian()//返回1，为小端；反之，为大端；
{  
	union
    {  
        unsigned int  a;  
        unsigned char b;  
    }c;  
    c.a = 1;  
	return 1 == c.b;  
}
```



## 位域

```c
struct
{
  unsigned int widthValidated : 1;
  unsigned int heightValidated : 1;
} status;
```

现在，上面的结构中，status 变量将占用 4 个字节的内存空间，但是只有 2 位被用来存储值。如果您用了 32 个变量，每一个变量宽度为 1 位，那么 status 结构将使用 4 个字节，但只要您再多用一个变量，如果使用了 33 个变量，那么它将分配内存的下一段来存储第 33 个变量，这个时候就开始使用 8 个字节。

> 即用完每一个状态，分段函数



## 输入输出

```
#include<stdio.h>
char s1[100];
int i;
scanf("%s %d", s1, &i);
printf("%s--%d",s1,i);

c = getchar();
putchar(c);

char str[100];
gets(str);
puts(str);
```



```c
    FILE *fp = NULL;
    fp = fopen("tmp.txt","w+");

    fputc('a' + 8,fp);
    fputs("123456abcd\n中文\n",fp);
    fprintf(fp,"This is the func \"fprintf\" \n");
    fclose(fp);
    
    fp = fopen("tmp.txt","r");
    char s[100];
    fgets(s,15,(FILE *)fp);
    printf("读取到了:%s\n",s);

    fclose(fp);

```



[C 文件读写 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-file-io.html)

[C语言--file文件指针及操作 - BruceTyler - 博客园 (cnblogs.com)](https://www.cnblogs.com/liang-chen/p/11397558.html)





## 可变参数

va_start(v,l),需要指定长度，就很烂

**1.va_start**

```c
#include <stdarg.h>//必须包含头文件
/*
*   arg_ptr 指向函数参数列表中的第一个可选参数
*   argN  是位于第一个可选参数之前的固定参数, 或者说最后一个固定参数
*/
va_start(arg_ptr, argN)
```

**2.va_arg**

```cpp
#include <stdarg.h>//必须包含头文件
/*
*   返回参数列表中指针arg_ptr所指的参数, 返回类型为type.
*   并使指针arg_ptr指向参数列表中下一个参数.
*   返回的是可选参数, 不包括固定参数.
*/
va_arg(arg_ptr, type)
```

**3.va_end**

```cpp
#include <stdarg.h>//必须包含头文件
/*
*   清空参数列表, 并置参数指针arg_ptr无效.
*/
va_end(arg_ptr)
```





```c
#include <stdio.h>
#include <stdarg.h>
 
double average(int num,...)
{
 
    va_list valist;
    double sum = 0.0;
    int i;
 
    /* 为 num 个参数初始化 valist */
    va_start(valist, num);
 
    /* 访问所有赋给 valist 的参数 */
    for (i = 0; i < num; i++)
    {
       sum += va_arg(valist, int);
    }
    /* 清理为 valist 保留的内存 */
    va_end(valist);
 
    return sum/num;
}
 
int main()
{
   printf("Average of 2, 3, 4, 5 = %f\n", average(4, 2,3,4,5));
   printf("Average of 5, 10, 15 = %f\n", average(3, 5,10,15));
}
```



## 内存管理

| 序号 | 函数和描述                                                   |
| ---- | ------------------------------------------------------------ |
| 1    | **void \*calloc(int num, int size);** 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。 |
| 2    | **void free(void \*address);** 该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。 |
| 3    | **void \*malloc(int num);** 在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。 |
| 4    | **void \*realloc(void \*address, int newsize);** 该函数重新分配内存，把内存扩展到 **newsize**。 |
| 5    | **free( object); 释放内存**                                  |









# 数组和指针

> 本章介绍一下内容

- 关键字：`static`
- 运算符：`&、*(一元)`
- 如何创建并初始化数组
- 指针（在已学过的基础上）、指针和数组的关系
- 编写处理数组的函数
- 二维数组

## 数组

一些数组声明：

```c
float candy[365];
char code[12];
int states[50];
```



### 初始化数组

```c
int powers[8] = {1,2,4,8,16,32,64,128}; // 从ANSI C开始支持这种初始化
```

> 不支持ANSI的编译器会把这种形式的舒适化识别为语法错误，在数组声明前加上关键字staticke可解决此问题

> 使用const 声明数组
>
> ​	数组会被设置为只读，无法将新值写入数组。要创建制度数组，应该英const声明和初始化数组
>
> ​	`const int days[10]= {...}`



> TODO 12 static 存储类型警告

- 初始化列表中的项数与数组的大小不一致的结果：

  - 当初始化列表的项数**少于**数组元素个数时，编译器会把剩余的元素都**初始化为0**
  - 当初始化列表的项数**多于**数组元素个数时，编译器会使其为**错误**。

- 如果初始化数组时**省略**方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小

  ```c
  const int day[] = {31, 28, 31, 30, 31, 31, 30, 31};
  ```

- `sizof(day)`是整个数组的大小（以字节为单位），`sizeof(day[0])`是数组中一个元素的大小，前者除以后者就是 **数组元素的个数**。

  - 当数组作为函数的形参时，传过来的是数组的地址，而不是整个的数组空间，要正确获取数组的size：`sizeof直接操作数组本身，不通过函数处理，可以通过宏定义`



### 指定初始化器(C99)

​	可以在初始化列表中使用带方括号的下标指明待初始化的元素:

```c
int arr[6] = {[5] = 212}; // 把arr[5] 初始化为 212
```

在初始化一个元素后，未初始化的元素都会被设置未0.

- 未指定数组大小会怎样

  ```c
  int stuff[] = {1, [6] = 23}; // 数组的大小为能容得下的最小值
  ```



### 数组边界

​	在使用数组时，要防止数组下标超出边界。

​	如果超出数组边界， 编译器不会检查这种错误（有些编译器会发出警告，然后继续编译程序）

```c
int before = -99;
int arr[] = {1,2,3,4};
int after = 99;

// 打印原始before, after
printf("before: %d, after: %d\r\n", before, after);

for(int i = -1; i < 5; i++)
    printf("arr %d: %d\r\n", i, arr[i]);

//更改arr数组内的数据
for(int i = 0; i < 5; i++)
    arr[i] += 12;

//看看before、after是否受到了影响
printf("before: %d, after: %d\r\n", before, after);
```

output:

```ABAP
before: -99, after: 99
arr -1: 32760
arr 0: 1
arr 1: 2
arr 2: 3
arr 3: 4
arr 4: 99
before: -99, after: 111
```

可见，变量`after`的值被改变了.





## 多维数组

```c
 typeName arrName[dim1][dim2]...[dimN];
```

### 初始化二维数组

```c
float rain[YEARS][MONTHS] = 
{
	{1,2,3,4,...},
	{5,6,7,8,...},
	...
}
```

也可以省略内部的花括号，只保留最外面的一对花括号。

- 可以使用 {[4] [0] = 1}；像一维数组一样指定位置初始化。



## 数组和指针

> 数组名是数组首元素的地址
>
> `&var`  表示取`var`的地址
>
> `typeName * p `  表示声明一个typeName的指针p

- 指针的值是它所指向对象的地址
- 在指针前面使用 * 运算符可以取得该指针所指对象的值。
- 指针加1， 指针的值递增它所指向类型的大小（以字节为单位）；

### 使用指针形参

​		函数要处理数组必须知道何时开始、合适结束。

- 一种方法，是外加一个参数传递要处理的数组数目，比如数组长度。
- 另一个方法是传递两个指针，第1个指向数组开始处，第2个指向数组结束处。

```c
int sump(int *start, int *end)
{
	int total = 0;
    while (start < end)
    {
        total += *start;	// 把数组元素的值加起来
        start++;			// 指针指向下一个元素
    }
    return total;
}
```



- `*start++`: 先取指针指向的数，然后 start+=1
- `*++start`: 先让start+=1，然后取此时（增加后）start指向的值。



## 指针操作

- **赋值**：把地址付给指针。可用 数组名、待敌之运算符(`&`)的变量名、另一个指针进行赋值。地址类型要与指针类型兼容，不能将double类型的地址赋给指向int的指针，至少要避免不明智地类型转换。
- **解引用**：\*运算符给出指针指向地址上存储的值。
- **解值**：`&`也能作用到指针变量上，指出指针变量自身地址。
- **指针与整数相加**：整数会与指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。
- **递增指针、指针减去一个整数、迪安指针、指针求差**
- **比较**：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。



例子：

- ```c
  void swap(int *a, int *b)
  {
      // a, b 都是地址 交换两个地址上的取值
      int tmp;
      tmp = *b;
      *b = *a;
      *a = tmp;
  }
  
  
  // use:
  swap(&a, &b);
  ```

  通过修改地址上的值，影响函数形参本体的值。



> 注意
>
> - 不要使用未初始化的指针
>
>   未初始化的指针其值是一个随机值，可能擦写数据或代码，导致程序崩溃。可以使用一个现有变量的地址初始化该指针，或者使用malloc()函数先分配内存。

### 对形参使用const

```c
int sum(const int arr[], int n);
```

`const`会高速编译器，该函数不能修改arr指向的数组的内容，否则会捕获错误。



### const 的其他内容

- 把const数据或非const数据的地址初始化位指向const的指针或为其赋值是合法的。

  ```c
  double rates[5] = {1.2, 2.3, 3.4, 4.5};
  const double locked[4] = {0.1, 0.2, 0.3, 0.4};
  const double * pc = rates;
  pc = locked;
  pc = &rates[3];
  
  ```

- 只能把非const数据的地址赋给普通指针：

  ```c
  double rates[5] = {1.2, 2.3, 3.4, 4.5};
  const double locked[4] = {0.1, 0.2, 0.3, 0.4};
  double * pc = rates;
  pc = locked;  // 在我的win10上，gcc 8.1, 此处警告，能运行
  *pc += 1;     // 此处成功改变了const数组的取值
  pc = &rates[3];
  
  ```

- const与 \*位置的细节

  ```c
  // 1  const type *
  const double * p = rates;  // 可以修改p指向的地址，但是无法修改该地址上的值。
  
  // 2 type const * 
  double const * p = rates;  // 可以修改指针，但是无法修改取值。
  
  // 3 type * const p 
  double * const p = rates;  // 无法修改p指向的地址，但是可以修改该地址上的值
  
  ```

  奇怪的是，编译时抛出异常了，但是调试的时候并没有中断（VScode gcc 8.1）



## 指针和多维数组

示例：`int zippo[4][2]; // 内涵int数组的数组`

`zippo`的首元素是一个内涵两个int值的数组，所以zippo时这个内含两个int 值得数组得地址。

- 因为`zippo`是数组首元素的地址，所以`zippo`的值和`&zippo[0]`的值相同。
  - `zippo[0]`本身是一个内含两个帧数的数组，所以`zippo[0]`的值和它首元素（一个整数）的地址(`&zippo[0][0]`)相同。
  - `zippo[0]`是一个占用一个int大学奥对象的地址，而`zippo`是一个占用两个int大小对象的地址。由于这个整数和内含两个整数的数组都开始与同一个地址，所以`zippo`和`zippo[0]`的值相同。

[ 长度 ]: 







# 扩展

> [目录 · SDL中文教程 (tjumyk.github.io)](https://tjumyk.github.io/sdl-tutorial-cn/contents.html)