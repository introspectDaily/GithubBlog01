I"|J<h1 id="配置环境">配置环境</h1>

<h2 id="cmake-入门bushi">Cmake 入门(bushi)</h2>

<p>在Linux平台下使用Cmake生成Makefile并编译的流程如下：</p>

<ul>
  <li>编写Cmake配置文件CmakeLists.txt</li>
  <li>执行命令Cmake PATH 或者 ccmake PATH 生成 Makefile。 其中， PATH是CMakeLists.txt 所在的目录。</li>
  <li>使用 make 命令进行编译。</li>
</ul>

<h3 id="入门案例单个源文件">入门案例：单个源文件</h3>

<p>main.cc</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cm">/**
 * power - Calculate the power of number.
 * @param base: Base value.
 * @param exponent: Exponent value.
 *
 * @return base raised to the power exponent.
 */</span>
<span class="kt">double</span> <span class="nf">power</span><span class="p">(</span><span class="kt">double</span> <span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">exponent</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">exponent</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">*</span> <span class="n">base</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Usage: %s base exponent </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">double</span> <span class="n">base</span> <span class="o">=</span> <span class="n">atof</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="kt">int</span> <span class="n">exponent</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
  <span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="n">power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exponent</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%g ^ %d is %g</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">exponent</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<ul>
  <li>
    <p>编写<code class="language-plaintext highlighter-rouge">CMakeLists.txt</code></p>

    <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># CMake 最低版本要求</span>
<span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 2.8<span class="p">)</span>
<span class="c1"># 项目信息</span>
<span class="nb">project</span><span class="p">(</span>Deom1<span class="p">)</span>
<span class="c1">#指定生成目标</span>
<span class="nb">add_executable</span><span class="p">(</span>Demo main.cc<span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>编译项目</p>

    <ul>
      <li>在当前目录执行<code class="language-plaintext highlighter-rouge">cmake . </code> 得到Makefile后再使用 make 命令编译得到 Demo1可执行文件</li>
      <li>再VScode中，需要安装cmake插件，<code class="language-plaintext highlighter-rouge">ctrl shift p </code>，找的cmake configure，指定gcc等编译器，然后进入 bulid 目录， 最后执行 <code class="language-plaintext highlighter-rouge">cmake </code>(linux)  <code class="language-plaintext highlighter-rouge">mingw32-make.exe</code>(windows).然后就能获得 Demo1可执行文件了</li>
    </ul>
  </li>
</ul>

<h3 id="多个源文件">多个源文件</h3>

<blockquote>
  <p>示例：Demo2</p>
</blockquote>

<p>目录结构：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./Demo2
    |
    +--- main.cc
    |
    +--- MathFunctions.cc
    |
    +--- MathFunctions.h
</code></pre></div></div>

<p>对应CMakeLists.txt的内容：</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># CMake 最低版本号要求</span>
<span class="nb">cmake_minimum_required</span> <span class="p">(</span>VERSION 2.8<span class="p">)</span>
<span class="c1"># 项目信息</span>
<span class="nb">project</span> <span class="p">(</span>Demo2<span class="p">)</span>
<span class="c1"># 指定生成目标</span>
<span class="nb">add_executable</span><span class="p">(</span>Demo main.cc MathFunctions.cc<span class="p">)</span>
</code></pre></div></div>

<p>唯一的改动只是在 add_executable 命令中增加了一个 MathFunctions.cc 源文件。</p>

<p>更省事的方法是使用 <code class="language-plaintext highlighter-rouge">aux_source_directory</code>命令，该方法会查找指定目录下的所有源文件，然后将结果存进指定变量名。其语法如下</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">aux_source_directory</span><span class="p">(</span>&lt;dir&gt; &lt;variable&gt;<span class="p">)</span>
</code></pre></div></div>

<p>使用此命令，对应CMakeLists.txt</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># CMake 最低版本号要求</span>
<span class="nb">cmake_minimum_required</span> <span class="p">(</span>VERSION 2.8<span class="p">)</span>
<span class="c1"># 项目信息</span>
<span class="nb">project</span> <span class="p">(</span>Demo2<span class="p">)</span>
<span class="c1"># 查找当前目录下的所有源文件</span>
<span class="c1"># 并将名称保存到 DIR_SRCS 变量</span>
<span class="nb">aux_source_directory</span><span class="p">(</span>. DIR_SRCS<span class="p">)</span>
<span class="c1"># 指定生成目标</span>
<span class="nb">add_executable</span><span class="p">(</span>Demo <span class="si">${</span><span class="nv">DIR_SRCS</span><span class="si">}</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="多个目录-多个源文件">多个目录， 多个源文件</h3>

<blockquote>
  <p>Demo3</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./Demo3
    |
    +--- main.cc
    |
    +--- math/
          |
          +--- MathFunctions.cc
          |
          +--- MathFunctions.h
</code></pre></div></div>

<p>根目录中的CMakeLists.txt</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">project</span> <span class="p">(</span>Demo3<span class="p">)</span>
<span class="c1"># 查找当前目录下的所有源文件</span>
<span class="c1"># 并将名称保存到 DIR_SRCS 变量</span>
<span class="nb">aux_source_directory</span><span class="p">(</span>. DIR_SRCS<span class="p">)</span>
<span class="c1"># 添加 math 子目录</span>
<span class="nb">add_subdirectory</span><span class="p">(</span>math<span class="p">)</span>
<span class="c1"># 指定生成目标</span>
<span class="nb">add_executable</span><span class="p">(</span>Demo main.cc<span class="p">)</span>
<span class="c1"># 添加链接库</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>Demo MathFunctions<span class="p">)</span>
</code></pre></div></div>

<p>子目录中的CMakeLists.txt</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 查找当前目录下的所有源文件</span>
<span class="c1"># 并将名称保存到 DIR_LIB_SRCS 变量</span>
<span class="nb">aux_source_directory</span><span class="p">(</span>. DIR_LIB_SRCS<span class="p">)</span>
<span class="c1"># 生成链接库</span>
<span class="nb">add_library</span> <span class="p">(</span>MathFunctions <span class="si">${</span><span class="nv">DIR_LIB_SRCS</span><span class="si">}</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="makefile模板">Makefile模板</h2>

<blockquote>
  <p>小白想了几个小时，主要是必要的知识不知道或者忘记了</p>

  <div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">VERSION</span>  <span class="o">=</span>1.00
<span class="nv">CC</span>   <span class="o">=</span>gcc
<span class="nv">DEBUG</span>   <span class="o">=</span> 1
<span class="nv">CFLAGS</span>  <span class="o">=</span><span class="nt">-Wall</span> <span class="nt">-Og</span> <span class="nt">-fdiagnostics-color</span><span class="o">=</span>always

<span class="nv">BUILD_DIR</span> <span class="o">=</span> build
<span class="nv">OUTPUT</span> <span class="o">=</span> output

<span class="k">ifeq</span> <span class="nv">($(DEBUG), 1)</span>
<span class="nv">CFLAGS</span> <span class="o">+=</span> <span class="nt">-g</span> <span class="nt">-gdwarf-2</span> 
<span class="k">endif</span>

<span class="c"># FileSearch = $(foreach d, $(wildcard $1*), $(call rwildcard,$d/,$2) $(filter $2, $d))
# 示例：搜索LVGL_PATH下的所有.c文件，并将其路径(包含文件名)保存到LVGLC
# LVGLC := $(call rwildcard, $(LVGL_PATH), %.c)  
</span>
<span class="nv">C_SOURCES</span> <span class="o">=</span>  <span class="se">\</span>
<span class="p">$(</span>wildcard ./src/<span class="k">*</span>.c<span class="p">)</span>


<span class="nv">C_INCLUDES</span> <span class="o">=</span> <span class="se">\</span>
<span class="nt">-Iinc</span>


<span class="nv">CFLAGS</span> <span class="o">+=</span> <span class="p">$(</span>C_INCLUDES<span class="p">)</span>
<span class="nv">CFLAGS</span> <span class="o">+=</span> <span class="nt">-MMD</span> <span class="nt">-MP</span> <span class="nt">-MF</span><span class="s2">"</span><span class="p">$(</span><span class="s2">@:%.o=%.d</span><span class="p">)</span><span class="s2">"</span>

<span class="nv">LIB_NAMES</span>  <span class="o">=</span> 
<span class="nv">LIB_PATH</span>  <span class="o">=</span> <span class="nt">-Llib</span>


<span class="nv">OBJECTS</span> <span class="o">=</span> <span class="p">$(</span>addprefix <span class="p">$(</span>BUILD_DIR<span class="p">)</span>/,<span class="p">$(</span>notdir <span class="p">$(</span>patsubst %.c, %.o, <span class="p">$(</span>C_SOURCES<span class="p">))))</span>
<span class="nv">DEPENDS</span> <span class="o">=</span> <span class="p">$(</span>patsubst %.o, %.d, <span class="p">$(</span>OBJECTS<span class="p">))</span>
<span class="err">vpath</span> <span class="err">%.c</span> <span class="nf">$(</span><span class="nb">sort</span> <span class="p">$(</span><span class="nb">dir</span> <span class="p">$(</span>C_SOURCES<span class="p">)))</span>


<span class="nv">TARGET</span>  <span class="o">=</span> <span class="nb">test</span>

<span class="nl">$(TARGET)</span><span class="o">:</span> <span class="nf">$(OBJECTS)  | MKDIR</span>
	<span class="p">$(</span>CC<span class="p">)</span> <span class="p">$(</span>OBJECTS<span class="p">)</span> <span class="p">$(</span>LIB_PATH<span class="p">)</span> <span class="p">$(</span>LIB_NAMES<span class="p">)</span> <span class="nt">-o</span> <span class="p">$(</span>OUTPUT<span class="p">)</span>/<span class="p">$(</span>TARGET<span class="p">)</span>.exe

<span class="nl">$(BUILD_DIR)/%.o</span><span class="o">:</span> <span class="nf">%.c Makefile | MKDIR</span>
	<span class="p">$(</span>CC<span class="p">)</span> <span class="nt">-c</span> <span class="p">$(</span>CFLAGS<span class="p">)</span> <span class="nt">-Wa</span>,-a,-ad,-alms<span class="o">=</span><span class="p">$(</span>BUILD_DIR<span class="p">)</span>/<span class="p">$(</span>notdir <span class="p">$(</span>&lt;:.c<span class="o">=</span>.lst<span class="p">))</span> <span class="nv">$&lt;</span> <span class="nt">-o</span> <span class="nv">$@</span>



<span class="nl">.PHONY</span><span class="o">:</span><span class="nf">clean</span>

<span class="nl">MKDIR</span><span class="o">:</span>
	<span class="p">$(</span>shell <span class="k">if</span> <span class="o">[</span> <span class="o">!</span> <span class="nt">-e</span> <span class="p">$(</span>OUTPUT<span class="p">)</span> <span class="o">]</span><span class="p">;</span><span class="k">then </span><span class="nb">mkdir</span> <span class="nt">-p</span> <span class="p">$(</span>OUTPUT<span class="p">);</span> <span class="k">fi</span><span class="p">)</span>
	<span class="p">$(</span>shell <span class="k">if</span> <span class="o">[</span> <span class="o">!</span> <span class="nt">-e</span> <span class="p">$(</span>BUILD_DIR<span class="p">)</span> <span class="o">]</span><span class="p">;</span><span class="k">then </span><span class="nb">mkdir</span> <span class="nt">-p</span> <span class="p">$(</span>BUILD_DIR<span class="p">);</span> <span class="k">fi</span><span class="p">)</span>

<span class="nl">clean</span><span class="o">:</span>
	<span class="p">@</span><span class="nb">echo</span> <span class="s2">"Remove linked and compiled files......"</span>
	<span class="nb">rm</span> <span class="nt">-rf</span> <span class="p">$(</span>BUILD_DIR<span class="p">)</span>/<span class="k">*</span>.o
	<span class="nb">rm</span> <span class="nt">-rf</span> <span class="p">$(</span>OUTPUT<span class="p">)</span>/<span class="k">*</span>.exe

<span class="nl">debug</span><span class="o">:</span>
	<span class="p">@</span><span class="nb">echo</span> <span class="p">$(</span>CFLAGS<span class="p">)</span>

<span class="k">-include</span><span class="sx"> $(wildcard $(BUILD_DIR)/*.d)</span>
</code></pre></div>  </div>
</blockquote>

<h3 id="bug记录">bug记录</h3>

<ol>
  <li>如果移动了一个{name}.c,{name}.h, 务必在Makefile里做对应的修改，尤其是使用了上述模板的自动搜索功能</li>
</ol>

<h2 id="vscode配置cc环境">VSCode配置C/C++环境</h2>

<h3 id="使用cmake">使用Cmake</h3>

<p>使用插件:</p>

<p>新建文件：<code class="language-plaintext highlighter-rouge">CMakeLists.txt</code></p>

<p>输入：</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">project</span><span class="p">(</span>project_name<span class="p">)</span>

<span class="nb">add_executable</span><span class="p">(</span>output_name main.cpp swap.cpp ...<span class="p">(</span>source cpp<span class="p">)</span>...<span class="p">)</span>

</code></pre></div></div>

<p>然后保存，插件会自动生成目录build</p>

<h4 id="多目录-多文件cmakeliststxt">多目录 多文件CMakeLists.txt</h4>

<blockquote>
  <table>
    <tbody>
      <tr>
        <td>- CMakeLists.txt</td>
      </tr>
    </tbody>
  </table>

  <table>
    <tbody>
      <tr>
        <td>- math</td>
      </tr>
    </tbody>
  </table>

  <table>
    <tbody>
      <tr>
        <td>​</td>
        <td>- *.cc</td>
      </tr>
    </tbody>
  </table>

  <table>
    <tbody>
      <tr>
        <td>​</td>
        <td>- *.h</td>
      </tr>
    </tbody>
  </table>

  <p>main.cc</p>
</blockquote>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">project</span><span class="p">(</span>Demo3_1<span class="p">)</span>

<span class="nb">aux_source_directory</span><span class="p">(</span>. DIR_SRCS<span class="p">)</span>
<span class="nb">aux_source_directory</span><span class="p">(</span>math Math_SRCS<span class="p">)</span>

<span class="nb">include_directories</span><span class="p">(</span>math<span class="p">)</span>


<span class="nb">add_executable</span><span class="p">(</span>main <span class="si">${</span><span class="nv">DIR_SRCS</span><span class="si">}</span> <span class="si">${</span><span class="nv">Math_SRCS</span><span class="si">}</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="launchjson样例">launch.json样例</h4>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"0.2.0"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"configurations"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"C/C++: g++ build and debug active file"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"cppdbg"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"request"</span><span class="p">:</span><span class="w"> </span><span class="s2">"launch"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"program"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${fileDirname}/build/${fileBasenameNoExtension}"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"args"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
      </span><span class="nl">"stopAtEntry"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
      </span><span class="nl">"cwd"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${workspaceFolder}"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"environment"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
      </span><span class="nl">"externalConsole"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
      </span><span class="nl">"MIMode"</span><span class="p">:</span><span class="w"> </span><span class="s2">"gdb"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"miDebuggerPath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"D:/Program files/mingw64/bin/gdb.exe"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"setupCommands"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
          </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Enable pretty-printing for gdb"</span><span class="p">,</span><span class="w">
          </span><span class="nl">"text"</span><span class="p">:</span><span class="w"> </span><span class="s2">"-enable-pretty-printing"</span><span class="p">,</span><span class="w">
          </span><span class="nl">"ignoreFailures"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
        </span><span class="p">}</span><span class="w">
      </span><span class="p">],</span><span class="w">
      </span><span class="nl">"preLaunchTask"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Build"</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h4 id="taskjson样例">task.json样例</h4>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2.0.0"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"options"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"cwd"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${fileDirname}/build"</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nl">"tasks"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"shell"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"label"</span><span class="p">:</span><span class="w"> </span><span class="s2">"cmake"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"command"</span><span class="p">:</span><span class="w"> </span><span class="s2">"cmake"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"args"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="s2">".."</span><span class="w">
            </span><span class="p">]</span><span class="w">
        </span><span class="p">},</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"label"</span><span class="p">:</span><span class="w"> </span><span class="s2">"make"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"group"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="nl">"kind"</span><span class="p">:</span><span class="w"> </span><span class="s2">"build"</span><span class="p">,</span><span class="w">
                </span><span class="nl">"isDefault"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
            </span><span class="p">},</span><span class="w">
            </span><span class="nl">"command"</span><span class="p">:</span><span class="w"> </span><span class="s2">"mingw32-make.exe"</span><span class="p">,</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">:Windows</span><span class="w">  </span><span class="err">make:</span><span class="w"> </span><span class="err">Linex下</span><span class="w">
            </span><span class="nl">"args"</span><span class="p">:</span><span class="w"> </span><span class="p">[]</span><span class="w">
        </span><span class="p">},</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"label"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Build"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"dependsOn"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="s2">"cmake"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"make"</span><span class="w">
            </span><span class="p">]</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">],</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h4 id="lanuchjson">lanuch.json</h4>

<p>将<code class="language-plaintext highlighter-rouge">"program:"</code> 设置为build路径下，对应好CMakeLists.txt确定的名字</p>

<h3 id="vscode调试c语言技巧">Vscode调试C语言技巧</h3>

<h4 id="强行显示数组">强行显示数组</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*arr_name@10、 *(int(*)[10])arr_name
</code></pre></div></div>

<h1 id="c语言笔记电赛">C语言笔记(电赛)</h1>

<h2 id="运算符优先级">运算符优先级</h2>

<table>
  <thead>
    <tr>
      <th>优先级</th>
      <th>运算符</th>
      <th>名称或含义</th>
      <th>使用形式</th>
      <th>结合方向</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>[]</td>
      <td>数组下标</td>
      <td>数组名[常量表达式]</td>
      <td>左到右</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>()</td>
      <td>圆括号</td>
      <td>（表达式）/函数名(形參表)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>.</td>
      <td>成员选择（对象）</td>
      <td>对象.成员名</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>-&gt;</td>
      <td>成员选择（指针）</td>
      <td>对象指针-&gt;成员名</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>2</td>
      <td>-</td>
      <td>负号运算符</td>
      <td>-表达式</td>
      <td>右到左</td>
      <td>单目运算符</td>
    </tr>
    <tr>
      <td> </td>
      <td>(类型)</td>
      <td>强制类型转换</td>
      <td>(数据类型)表达式</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>++</td>
      <td>自增运算符</td>
      <td>++变量名/变量名++</td>
      <td>单目运算符</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>–</td>
      <td>自减运算符</td>
      <td>–变量名/变量名–</td>
      <td>单目运算符</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>*</td>
      <td>取值运算符</td>
      <td>*指针变量</td>
      <td>单目运算符</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>&amp;</td>
      <td>取地址运算符</td>
      <td>&amp;变量名</td>
      <td>单目运算符</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>!</td>
      <td>逻辑非运算符</td>
      <td>!表达式</td>
      <td>单目运算符</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>~</td>
      <td>按位取反运算符</td>
      <td>~表达式</td>
      <td>单目运算符</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>sizeof</td>
      <td>长度运算符</td>
      <td>sizeof(表达式)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>3</td>
      <td>/</td>
      <td>除</td>
      <td>表达式/表达式</td>
      <td>左到右</td>
      <td>双目运算符</td>
    </tr>
    <tr>
      <td> </td>
      <td>*</td>
      <td>乘</td>
      <td>表达式*表达式</td>
      <td>双目运算符</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>%</td>
      <td>余数（取模）</td>
      <td>整型表达式/整型表达式</td>
      <td>双目运算符</td>
      <td> </td>
    </tr>
    <tr>
      <td>4</td>
      <td>+</td>
      <td>加</td>
      <td>表达式+表达式</td>
      <td>左到右</td>
      <td>双目运算符</td>
    </tr>
    <tr>
      <td> </td>
      <td>-</td>
      <td>减</td>
      <td>表达式-表达式</td>
      <td>双目运算符</td>
      <td> </td>
    </tr>
    <tr>
      <td>5</td>
      <td>«</td>
      <td>左移</td>
      <td>变量«表达式</td>
      <td>左到右</td>
      <td>双目运算符</td>
    </tr>
    <tr>
      <td> </td>
      <td>»</td>
      <td>右移</td>
      <td>变量»表达式</td>
      <td>双目运算符</td>
      <td> </td>
    </tr>
    <tr>
      <td>6</td>
      <td>&gt;</td>
      <td>大于</td>
      <td>表达式&gt;表达式</td>
      <td>左到右</td>
      <td>双目运算符</td>
    </tr>
    <tr>
      <td> </td>
      <td>&gt;=</td>
      <td>大于等于</td>
      <td>表达式&gt;=表达式</td>
      <td>双目运算符</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>&lt;</td>
      <td>小于</td>
      <td>表达式&lt;表达式</td>
      <td>双目运算符</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>&lt;=</td>
      <td>小于等于</td>
      <td>表达式&lt;=表达式</td>
      <td>双目运算符</td>
      <td> </td>
    </tr>
    <tr>
      <td>7</td>
      <td>==</td>
      <td>等于</td>
      <td>表达式==表达式</td>
      <td>左到右</td>
      <td>双目运算符</td>
    </tr>
    <tr>
      <td> </td>
      <td>!=</td>
      <td>不等于</td>
      <td>表达式!= 表达式</td>
      <td>双目运算符</td>
      <td> </td>
    </tr>
    <tr>
      <td>8</td>
      <td>&amp;</td>
      <td>按位与</td>
      <td>表达式&amp;表达式</td>
      <td>左到右</td>
      <td>双目运算符</td>
    </tr>
    <tr>
      <td>9</td>
      <td>^</td>
      <td>按位异或</td>
      <td>表达式^表达式</td>
      <td>左到右</td>
      <td>双目运算符</td>
    </tr>
    <tr>
      <td>10</td>
      <td>|</td>
      <td>按位或</td>
      <td>表达式|表达式</td>
      <td>左到右</td>
      <td>双目运算符</td>
    </tr>
    <tr>
      <td>11</td>
      <td>&amp;&amp;</td>
      <td>逻辑与</td>
      <td>表达式&amp;&amp;表达式</td>
      <td>左到右</td>
      <td>双目运算符</td>
    </tr>
    <tr>
      <td>12</td>
      <td>||</td>
      <td>逻辑或</td>
      <td>表达式||表达式</td>
      <td>左到右</td>
      <td>双目运算符</td>
    </tr>
    <tr>
      <td>13</td>
      <td>?:</td>
      <td>条件运算符</td>
      <td>表达式1? 表达式2: 表达式3</td>
      <td>右到左</td>
      <td>三目运算符</td>
    </tr>
    <tr>
      <td>14</td>
      <td>=</td>
      <td>赋值运算符</td>
      <td>变量=表达式</td>
      <td>右到左</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>/=</td>
      <td>除后赋值</td>
      <td>变量/=表达式</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>*=</td>
      <td>乘后赋值</td>
      <td>变量*=表达式</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>%=</td>
      <td>取模后赋值</td>
      <td>变量%=表达式</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>+=</td>
      <td>加后赋值</td>
      <td>变量+=表达式</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>-=</td>
      <td>减后赋值</td>
      <td>变量-=表达式</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>«=</td>
      <td>左移后赋值</td>
      <td>变量«=表达式</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>»=</td>
      <td>右移后赋值</td>
      <td>变量»=表达式</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>&amp;=</td>
      <td>按位与后赋值</td>
      <td>变量&amp;=表达式</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>^=</td>
      <td>按位异或后赋值</td>
      <td>变量^=表达式</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>|=</td>
      <td>按位或后赋值</td>
      <td>变量|=表达式</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>15</td>
      <td>,</td>
      <td>逗号运算符</td>
      <td>表达式,表达式,…</td>
      <td>左到右</td>
      <td>从左向右顺序运算</td>
    </tr>
  </tbody>
</table>

<h2 id="动态分配数组">动态分配数组</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="n">pd</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">len</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

<span class="n">free</span><span class="p">(</span><span class="n">pd</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="枚举--enum">枚举  enum</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">WeekDay</span><span class="p">{</span><span class="n">Sunday</span><span class="p">,</span> <span class="n">Monday</span><span class="p">,</span> <span class="n">Tuesday</span><span class="p">,</span> <span class="n">Wednesday</span><span class="p">,</span> <span class="n">Thursday</span><span class="p">,</span> <span class="n">Friday</span><span class="p">,</span> <span class="n">Staurday</span><span class="p">};</span>
</code></pre></div></div>

<p><a href="http://c.biancheng.net/view/2034.html">C语言枚举类型（C语言enum用法）详解 (biancheng.net)</a></p>

<p>1）枚举的大小是按照enum中元素最大值所占的内存大小来决定的，不像结构体那样有多少个元素就按各个元素所占字节叠加。</p>

<p>2）当枚举成员的值小于4个字节时，占4个字节。</p>

<p>3）当枚举成员的值大于4个字节时，最大只能是longlong类型，占8个字节。</p>

<h2 id="指针">指针</h2>

<p><img src="D:\STUDY\C\CStudy.assets\image-20211024135724668-16350550466901.png" alt="image-20211024135724668" /></p>

<h3 id="函数指针">函数指针</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">function</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//执行代码</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">FP</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="err">；</span>
    <span class="n">FP</span><span class="o">=</span> <span class="n">function</span><span class="p">;</span>    <span class="c1">//第一种赋值方法</span>
   <span class="c1">// FP = &amp;function;   //第二种赋值方法</span>
    <span class="n">FP</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>       <span class="c1">//第一种调用方法</span>
   <span class="c1">// (*FP)(1,2);  //第二种调用方法</span>
 
<span class="p">}</span>
</code></pre></div></div>

<h2 id="字符串">字符串</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="kt">char</span> <span class="n">s1</span><span class="p">[];</span>
<span class="kt">char</span> <span class="n">s2</span><span class="p">[];</span>

<span class="n">strcpy</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">);</span>
<span class="c1">// 复制字符串s2到字符串s1</span>

<span class="n">strcat</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">);</span>
<span class="c1">//连接字符串s2到s1的末尾</span>

<span class="n">strlen</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>
<span class="c1">//返回字符串s1的长度</span>

<span class="n">strcmp</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">);</span>
<span class="c1">//如果s1和s2相同的，则返回0；如果s1&lt;s2，则返回小于0；如果s1&gt;s2，则返回大于0</span>

<span class="n">strchar</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">ch</span><span class="p">);</span>
<span class="c1">//返回一个指针，指向字符串s1中s2的第一次出现的位置</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">strstr</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">haystack</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">needle</span><span class="p">);</span>
<span class="c1">//在字符串 haystack 中查找第一次出现字符串 needle 的位置，不包含终止符 '\0'。</span>

</code></pre></div></div>

<h3 id="字符串格式化输出">字符串格式化输出</h3>

<p>C语言中格式字符串的一般形式为： % [ 标志 ] [ 输出最小宽度 ] [. 精度 ] [ 长度 ] 类型 ， 其中方括号[]中的项为可选项。</p>

<p>一、类型</p>

<p>我们用一定的字符用以表示输出数据的类型，其格式符和意义下表所示：</p>

<p>字符                  意义</p>

<p>a         浮点数、十六进制数字和p-计数法(C99)</p>

<p>A         浮点数、十六进制数字和p-计数法(C99)</p>

<p>c         输出单个字符</p>

<p>d         以十进制形式输出带符号整数(正数不输出符号)</p>

<p>e         以指数形式输出单、双精度实数</p>

<p>E         以指数形式输出单、双精度实数</p>

<p>f          以小数形式输出单、双精度实数</p>

<p>g         以%f%e中较短的输出宽度输出单、双精度实数,%e格式在指数小于-4或者大 于等于精度时使用</p>

<p>G         以%f%e中较短的输出宽度输出单、双精度实数,%e格式在指数小于-4或者大于等于精度时使用</p>

<p>i          有符号十进制整数(与%d相同)</p>

<p>o         以八进制形式输出无符号整数(不输出前缀O)</p>

<p>p         指针</p>

<p>s          输出字符串</p>

<p>x          以十六进制形式输出无符号整数(不输出前缀OX)</p>

<p>X          以十六进制形式输出无符号整数 (不输出前缀OX)</p>

<p>u          以十进制形式输出无符号整数</p>

<p>二、标志</p>

<p>标志字符为 - 、 + 、 # 、 空格 和 0 五种，其意义下表所示：</p>

<p>字符                意 义</p>

<p>-            结果左对齐，右边填空格</p>

<p>+            输出符号(正号或负号)</p>

<p>空格         输出值为正时冠以空格，为负时冠以负号</p>

<p>#            对c，s，d，u类无影响；对o类，在输出时加前缀0；对x类，在输出时加前缀0x或者0X；对g，G 类防止尾随0被删除；</p>

<p>​            对于所有的浮点形式，#保证了即使不跟任何数字，也打印一个小数点字符</p>

<p>0            对于所有的数字格式，用前导0填充字段宽度，若出现-标志或者指定了精度(对于整数),忽略</p>

<p>三、输出最小宽度</p>

<p>用十进制整数来表示输出的最少位数。若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。</p>

<p>四、精度</p>

<p>精度 格式符以“.”开头，后跟十进制整数。本项的意义是： 如果输出数字，则表示小数的位数；如果输出的是字符，则表示输出字符的个数；若实际位数大于所定义的精度数，则截去超过的部分 。</p>

<p>五、长度</p>

<p>长度格式符为 h , l 两种， h 表示按短整型量输出， l 表示按长整型量输出。</p>

<p>h 和 整数转换说明符 一起使用，表示一个short int 或者unsigned short int类型的数值，</p>

<p>示例： %hu，%hx，%6.4hd</p>

<p>hh 和 整数转换说明符 一起使用，表示一个singed char 或者unsigned char类型的数值，</p>

<p>示例： %hhu，%hhx，%6.4hhd</p>

<p>j 和 整数转换说明符 一起使用，表示一个intmax_t或者uintmax_t类型的数值，</p>

<p>示例： %jd,%8jx</p>

<p>l 和 整数转换说明符 一起使用，表示一个long int 或者unsigned long int类型的数值，</p>

<p>示例： %ld,%8lu</p>

<p>ll 和 整数转换说明符 一起使用，表示一个long int 或者unsigned long int类型的数值(C99)，</p>

<p>示例： %lld,%8llu</p>

<p>L 和 浮点转换说明符 一起使用，表示一个long double的值，示例：%Lf，%10.4Le</p>

<p>t 和 整数转换说明符 一起使用，表示一个ptrdiff_t值(两个指针之间的差相对应的类型)(C99)，</p>

<p>示例： %td,%12ti</p>

<p>z 和 整数转换说明符 一起使用，表示一个size_t值(sizeof返回的类型)(C99)，</p>

<p>示例： %zd,%12zx</p>

<blockquote>
  <p>UNICODE编码:<a href="https://wangwl.net/static/pages/unicode.html">一文彻底搞懂Unicode编码问题 (wangwl.net)</a></p>
</blockquote>

<h3 id="字符串正则化读取">字符串正则化读取</h3>

<blockquote>
  <p>成功则返回参数数目，失败则返回-1，错误原因存于errno中</p>
</blockquote>

<pre><code class="language-C">void sscanf_test(void)
{
	int ret;
	char *string;
	int  digit;
	char buf1[255];
	char buf2[255];
	char buf3[255];
	char buf4[255];
 
	/*1.最简单的用法*/
	string = "china beijing 123";
	ret = sscanf(string, "%s %s %d", buf1, buf2, &amp;digit);
	printf("1.string=%s\n", string);
	printf("1.ret=%d, buf1=%s, buf2=%s, digit=%d\n\n", ret, buf1, buf2, digit);
	/*
	**执行结果:
	**1.ret=3, buf1=china, buf2=beijing, digit=123
	**可以看出,sscanf的返回值是读取的参数个数
	*/
 
	/*2.取指定长度的字符串*/
	string = "123456789";
	sscanf(string, "%5s", buf1);
	printf("2.string=%s\n", string);
	printf("2.buf1=%s\n\n", buf1);
	/*
	**执行结果:
	**2.buf1=12345
	*/
 
	/*3.取到指定字符为止的字符串*/
	string = "123/456";
	sscanf(string, "%[^/]", buf1);
	printf("3.string=%s\n", string);
	printf("3.buf1=%s\n\n", buf1);
	/*
	**执行结果:
	**3.buf1=123
	*/
 
	/*4.取到指定字符集为止的字符串*/
	string = "123abcABC";
	sscanf(string, "%[^A-Z]", buf1);
	printf("4.string=%s\n", string);
	printf("4.buf1=%s\n\n", buf1);
	/*
	**执行结果:
	**4.buf1=123abc
	*/
 
	/*5.取仅包含指定字符集的字符串*/
	string = "0123abcABC";
	sscanf(string, "%[0-9]%[a-z]%[A-Z]", buf1, buf2, buf3);
	printf("5.string=%s\n", string);
	printf("5.buf1=%s, buf2=%s, buf3=%s\n\n", buf1, buf2, buf3);
	/*
	**执行结果:
	**5.buf1=123, buf2=abc, buf3=ABC
	*/
 
	/*6.获取指定字符中间的字符串*/
	string = "ios&lt;android&gt;wp7";
	sscanf(string, "%*[^&lt;]&lt;%[^&gt;]", buf1);
	printf("6.string=%s\n", string);
	printf("6.buf1=%s\n\n", buf1);
	/*
	**执行结果:
	**6.buf1=android
	*/
 
	/*7.指定要跳过的字符串*/
	string = "iosVSandroid";
	sscanf(string, "%[a-z]VS%[a-z]", buf1, buf2);
	printf("7.string=%s\n", string);
	printf("7.buf1=%s, buf2=%s\n\n", buf1, buf2);
	/*
	**执行结果:
	**7.buf1=ios, buf2=android
	*/
 
	/*8.分割以某字符隔开的字符串*/
	string = "android-iphone-wp7";
	/*
	**字符串取道'-'为止,后面还需要跟着分隔符'-',
	**起到过滤作用,有点类似于第7点
	*/
	sscanf(string, "%[^-]-%[^-]-%[^-]", buf1, buf2, buf3);
	printf("8.string=%s\n", string);
	printf("8.buf1=%s, buf2=%s, buf3=%s\n\n", buf1, buf2, buf3);
	/*
	**执行结果:
	**8.buf1=android, buf2=iphone, buf3=wp7
	*/
 
	/*9.提取邮箱地址*/
	string = "Email:beijing@sina.com.cn";
	sscanf(string, "%[^:]:%[^@]@%[^.].%s", buf1, buf2, buf3, buf4);
	printf("9.string=%s\n", string);
	printf("9.buf1=%s, buf2=%s, buf3=%s, buf4=%s\n\n", buf1, buf2, buf3, buf4);
	/*
	**执行结果:
	**9.buf1=Email, buf2=beijing, buf3=sina, buf4=com.cn
	*/
 
	/*10.过滤掉不想截取或不需要的字符串--补充,
	**在%号后面加一*号,代表过滤这个字符串,不读取
	*/
	string = "android iphone wp7";
	sscanf(string, "%s %*s %s", buf1, buf2);
	printf("10.string=%s\n", string);
	printf("10.buf1=%s, buf2=%s\n\n", buf1, buf2);
	/*
	**执行结果:
	**10.android wp7
	*/
}

</code></pre>

<h4 id="sscanf踩坑">sscanf踩坑</h4>

<blockquote>
  <p><a href="https://blog.csdn.net/Eric__zh/article/details/110181480">(43条消息) sscanf取值异常的问题笔记_Eric__zh的博客-CSDN博客_sscanf读取数值不对</a></p>
</blockquote>

<p>sscanf取的值按4字节写，在stm32中可能是该种原因导致访问越界导致的hardfault。</p>

<h2 id="结构体">结构体</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">struct_name</span>
<span class="p">{</span>
   <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
   <span class="kt">char</span> <span class="n">sno</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span>

<span class="p">}</span><span class="n">Student</span><span class="p">,</span> <span class="o">*</span><span class="n">stu</span><span class="p">;</span>  <span class="c1">// 没有typedef则是变量，否则是新结构名 </span>

<span class="n">Student</span> <span class="n">zs</span><span class="p">;</span>  <span class="c1">// 等价于 struct struct_name zs;</span>
<span class="c1">// 。。。</span>
<span class="n">stu</span> <span class="n">p</span><span class="p">;</span>
<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zs</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>
    <p>结构体指针</p>

    <p>(*指针变量名).成员名  与 指针变量名-&gt;成员名 效果相同</p>
  </li>
</ul>

<ol>
  <li>默认情况下，结构体的大小是结构体中最长类型的整数倍。</li>
  <li>结构体中的空间分布是按照结构体中最长类型对齐的。</li>
  <li>结构体中不同类型的成员，一定是按照自己的类型对齐。比如，int型的起始地址一定是4的整数倍，short型的首地址一定是2的整数倍。。。</li>
</ol>

<h2 id="共用体">共用体</h2>

<blockquote>
  <p>共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。</p>

  <p>union:共用一个内存首地址</p>
</blockquote>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">union</span> <span class="n">Data</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
   <span class="kt">float</span> <span class="n">f</span><span class="p">;</span>
   <span class="kt">char</span>  <span class="n">str</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
<span class="p">}</span> <span class="n">data</span><span class="p">;</span>
</code></pre></div></div>

<p>共用体占用的内存应足够存储共用体中最大的成员。例如，在上面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。</p>

<h3 id="共用体判断系统大小端">共用体判断系统大小端</h3>

<blockquote>
  <p><strong>大端模式(</strong>Big-endian)，是指数据的高字节保存在内存的低地址中，而<strong>数据的低字节保存在内存的高地址中</strong>，这样的存储模式有点儿类似于把数据当作字符串顺序处理:地址由小向大增加，而数据从高位往低位放;</p>

  <p><strong>小端模式</strong>(Little-endian)，是指数据的高字节保存在内存的高地址中，而<strong>数据的低字节保存在内存的低地址中</strong>，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。</p>
</blockquote>

<pre><code class="language-C">int checkCPUendian()//返回1，为小端；反之，为大端；
{  
	union
    {  
        unsigned int  a;  
        unsigned char b;  
    }c;  
    c.a = 1;  
	return 1 == c.b;  
}
</code></pre>

<h2 id="位域">位域</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">widthValidated</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">heightValidated</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span> <span class="n">status</span><span class="p">;</span>
</code></pre></div></div>

<p>现在，上面的结构中，status 变量将占用 4 个字节的内存空间，但是只有 2 位被用来存储值。如果您用了 32 个变量，每一个变量宽度为 1 位，那么 status 结构将使用 4 个字节，但只要您再多用一个变量，如果使用了 33 个变量，那么它将分配内存的下一段来存储第 33 个变量，这个时候就开始使用 8 个字节。</p>

<blockquote>
  <p>即用完每一个状态，分段函数</p>
</blockquote>

<h2 id="输入输出">输入输出</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include&lt;stdio.h&gt;
char s1[100];
int i;
scanf("%s %d", s1, &amp;i);
printf("%s--%d",s1,i);

c = getchar();
putchar(c);

char str[100];
gets(str);
puts(str);
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"tmp.txt"</span><span class="p">,</span><span class="s">"w+"</span><span class="p">);</span>

    <span class="n">fputc</span><span class="p">(</span><span class="sc">'a'</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span><span class="n">fp</span><span class="p">);</span>
    <span class="n">fputs</span><span class="p">(</span><span class="s">"123456abcd</span><span class="se">\n</span><span class="s">中文</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">fp</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span><span class="s">"This is the func </span><span class="se">\"</span><span class="s">fprintf</span><span class="se">\"</span><span class="s"> </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
    
    <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"tmp.txt"</span><span class="p">,</span><span class="s">"r"</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="n">fgets</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">15</span><span class="p">,(</span><span class="kt">FILE</span> <span class="o">*</span><span class="p">)</span><span class="n">fp</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"读取到了:%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>

    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

</code></pre></div></div>

<table>
  <tbody>
    <tr>
      <td>[C 文件读写</td>
      <td>菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-file-io.html)</td>
    </tr>
  </tbody>
</table>

<p><a href="https://www.cnblogs.com/liang-chen/p/11397558.html">C语言–file文件指针及操作 - BruceTyler - 博客园 (cnblogs.com)</a></p>

<h2 id="可变参数">可变参数</h2>

<p>va_start(v,l),需要指定长度，就很烂</p>

<p><strong>1.va_start</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdarg.h&gt;</span><span class="c1">//必须包含头文件</span><span class="cp">
</span><span class="cm">/*
*   arg_ptr 指向函数参数列表中的第一个可选参数
*   argN  是位于第一个可选参数之前的固定参数, 或者说最后一个固定参数
*/</span>
<span class="n">va_start</span><span class="p">(</span><span class="n">arg_ptr</span><span class="p">,</span> <span class="n">argN</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>2.va_arg</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdarg.h&gt;</span><span class="c1">//必须包含头文件</span><span class="cp">
</span><span class="cm">/*
*   返回参数列表中指针arg_ptr所指的参数, 返回类型为type.
*   并使指针arg_ptr指向参数列表中下一个参数.
*   返回的是可选参数, 不包括固定参数.
*/</span>
<span class="n">va_arg</span><span class="p">(</span><span class="n">arg_ptr</span><span class="p">,</span> <span class="n">type</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>3.va_end</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdarg.h&gt;</span><span class="c1">//必须包含头文件</span><span class="cp">
</span><span class="cm">/*
*   清空参数列表, 并置参数指针arg_ptr无效.
*/</span>
<span class="n">va_end</span><span class="p">(</span><span class="n">arg_ptr</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdarg.h&gt;</span><span class="cp">
</span> 
<span class="kt">double</span> <span class="nf">average</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">,...)</span>
<span class="p">{</span>
 
    <span class="kt">va_list</span> <span class="n">valist</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
 
    <span class="cm">/* 为 num 个参数初始化 valist */</span>
    <span class="n">va_start</span><span class="p">(</span><span class="n">valist</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
 
    <span class="cm">/* 访问所有赋给 valist 的参数 */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
       <span class="n">sum</span> <span class="o">+=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">valist</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cm">/* 清理为 valist 保留的内存 */</span>
    <span class="n">va_end</span><span class="p">(</span><span class="n">valist</span><span class="p">);</span>
 
    <span class="k">return</span> <span class="n">sum</span><span class="o">/</span><span class="n">num</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">"Average of 2, 3, 4, 5 = %f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">average</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">));</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">"Average of 5, 10, 15 = %f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">average</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">15</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="内存管理">内存管理</h2>

<table>
  <thead>
    <tr>
      <th>序号</th>
      <th>函数和描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td><strong>void *calloc(int num, int size);</strong> 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。</td>
    </tr>
    <tr>
      <td>2</td>
      <td><strong>void free(void *address);</strong> 该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。</td>
    </tr>
    <tr>
      <td>3</td>
      <td><strong>void *malloc(int num);</strong> 在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。</td>
    </tr>
    <tr>
      <td>4</td>
      <td><strong>void *realloc(void *address, int newsize);</strong> 该函数重新分配内存，把内存扩展到 <strong>newsize</strong>。</td>
    </tr>
    <tr>
      <td>5</td>
      <td><strong>free( object); 释放内存</strong></td>
    </tr>
  </tbody>
</table>

<h1 id="数组和指针">数组和指针</h1>

<blockquote>
  <p>本章介绍一下内容</p>
</blockquote>

<ul>
  <li>关键字：<code class="language-plaintext highlighter-rouge">static</code></li>
  <li>运算符：<code class="language-plaintext highlighter-rouge">&amp;、*(一元)</code></li>
  <li>如何创建并初始化数组</li>
  <li>指针（在已学过的基础上）、指针和数组的关系</li>
  <li>编写处理数组的函数</li>
  <li>二维数组</li>
</ul>

<h2 id="数组">数组</h2>

<p>一些数组声明：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">candy</span><span class="p">[</span><span class="mi">365</span><span class="p">];</span>
<span class="kt">char</span> <span class="n">code</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">states</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
</code></pre></div></div>

<h3 id="初始化数组">初始化数组</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">powers</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">128</span><span class="p">};</span> <span class="c1">// 从ANSI C开始支持这种初始化</span>
</code></pre></div></div>

<blockquote>
  <p>不支持ANSI的编译器会把这种形式的舒适化识别为语法错误，在数组声明前加上关键字staticke可解决此问题</p>
</blockquote>

<blockquote>
  <p>使用const 声明数组</p>

  <p>​	数组会被设置为只读，无法将新值写入数组。要创建制度数组，应该英const声明和初始化数组</p>

  <p>​	<code class="language-plaintext highlighter-rouge">const int days[10]= {...}</code></p>
</blockquote>

<blockquote>
  <p>TODO 12 static 存储类型警告</p>
</blockquote>

<ul>
  <li>
    <p>初始化列表中的项数与数组的大小不一致的结果：</p>

    <ul>
      <li>当初始化列表的项数<strong>少于</strong>数组元素个数时，编译器会把剩余的元素都<strong>初始化为0</strong></li>
      <li>当初始化列表的项数<strong>多于</strong>数组元素个数时，编译器会使其为<strong>错误</strong>。</li>
    </ul>
  </li>
  <li>
    <p>如果初始化数组时<strong>省略</strong>方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">day</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">31</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">};</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">sizof(day)</code>是整个数组的大小（以字节为单位），<code class="language-plaintext highlighter-rouge">sizeof(day[0])</code>是数组中一个元素的大小，前者除以后者就是 <strong>数组元素的个数</strong>。</p>

    <ul>
      <li>当数组作为函数的形参时，传过来的是数组的地址，而不是整个的数组空间，要正确获取数组的size：<code class="language-plaintext highlighter-rouge">sizeof直接操作数组本身，不通过函数处理，可以通过宏定义</code></li>
    </ul>
  </li>
</ul>

<h3 id="指定初始化器c99">指定初始化器(C99)</h3>

<p>​	可以在初始化列表中使用带方括号的下标指明待初始化的元素:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">212</span><span class="p">};</span> <span class="c1">// 把arr[5] 初始化为 212</span>
</code></pre></div></div>

<p>在初始化一个元素后，未初始化的元素都会被设置未0.</p>

<ul>
  <li>
    <p>未指定数组大小会怎样</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">stuff</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">23</span><span class="p">};</span> <span class="c1">// 数组的大小为能容得下的最小值</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="数组边界">数组边界</h3>

<p>​	在使用数组时，要防止数组下标超出边界。</p>

<p>​	如果超出数组边界， 编译器不会检查这种错误（有些编译器会发出警告，然后继续编译程序）</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">before</span> <span class="o">=</span> <span class="o">-</span><span class="mi">99</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">after</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>

<span class="c1">// 打印原始before, after</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"before: %d, after: %d</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">);</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"arr %d: %d</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

<span class="c1">//更改arr数组内的数据</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">12</span><span class="p">;</span>

<span class="c1">//看看before、after是否受到了影响</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"before: %d, after: %d</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">);</span>
</code></pre></div></div>

<p>output:</p>

<pre><code class="language-ABAP">before: -99, after: 99
arr -1: 32760
arr 0: 1
arr 1: 2
arr 2: 3
arr 3: 4
arr 4: 99
before: -99, after: 111
</code></pre>

<p>可见，变量<code class="language-plaintext highlighter-rouge">after</code>的值被改变了.</p>

<h2 id="多维数组">多维数组</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">typeName</span> <span class="n">arrName</span><span class="p">[</span><span class="n">dim1</span><span class="p">][</span><span class="n">dim2</span><span class="p">]...[</span><span class="n">dimN</span><span class="p">];</span>
</code></pre></div></div>

<h3 id="初始化二维数组">初始化二维数组</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">rain</span><span class="p">[</span><span class="n">YEARS</span><span class="p">][</span><span class="n">MONTHS</span><span class="p">]</span> <span class="o">=</span> 
<span class="p">{</span>
	<span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,...},</span>
	<span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,...},</span>
	<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>也可以省略内部的花括号，只保留最外面的一对花括号。</p>

<ul>
  <li>可以使用 {[4] [0] = 1}；像一维数组一样指定位置初始化。</li>
</ul>

<h2 id="数组和指针-1">数组和指针</h2>

<blockquote>
  <p>数组名是数组首元素的地址</p>

  <p><code class="language-plaintext highlighter-rouge">&amp;var</code>  表示取<code class="language-plaintext highlighter-rouge">var</code>的地址</p>

  <p><code class="language-plaintext highlighter-rouge">typeName * p </code>  表示声明一个typeName的指针p</p>
</blockquote>

<ul>
  <li>指针的值是它所指向对象的地址</li>
  <li>在指针前面使用 * 运算符可以取得该指针所指对象的值。</li>
  <li>指针加1， 指针的值递增它所指向类型的大小（以字节为单位）；</li>
</ul>

<h3 id="使用指针形参">使用指针形参</h3>

<p>​		函数要处理数组必须知道何时开始、合适结束。</p>

<ul>
  <li>一种方法，是外加一个参数传递要处理的数组数目，比如数组长度。</li>
  <li>另一个方法是传递两个指针，第1个指向数组开始处，第2个指向数组结束处。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sump</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="o">*</span><span class="n">start</span><span class="p">;</span>	<span class="c1">// 把数组元素的值加起来</span>
        <span class="n">start</span><span class="o">++</span><span class="p">;</span>			<span class="c1">// 指针指向下一个元素</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">*start++</code>: 先取指针指向的数，然后 start+=1</li>
  <li><code class="language-plaintext highlighter-rouge">*++start</code>: 先让start+=1，然后取此时（增加后）start指向的值。</li>
</ul>

<h2 id="指针操作">指针操作</h2>

<ul>
  <li><strong>赋值</strong>：把地址付给指针。可用 数组名、待敌之运算符(<code class="language-plaintext highlighter-rouge">&amp;</code>)的变量名、另一个指针进行赋值。地址类型要与指针类型兼容，不能将double类型的地址赋给指向int的指针，至少要避免不明智地类型转换。</li>
  <li><strong>解引用</strong>：*运算符给出指针指向地址上存储的值。</li>
  <li><strong>解值</strong>：<code class="language-plaintext highlighter-rouge">&amp;</code>也能作用到指针变量上，指出指针变量自身地址。</li>
  <li><strong>指针与整数相加</strong>：整数会与指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。</li>
  <li><strong>递增指针、指针减去一个整数、迪安指针、指针求差</strong></li>
  <li><strong>比较</strong>：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。</li>
</ul>

<p>例子：</p>

<ul>
  <li>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// a, b 都是地址 交换两个地址上的取值</span>
    <span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
    <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
    <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
  
  
<span class="c1">// use:</span>
<span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</code></pre></div>    </div>

    <p>通过修改地址上的值，影响函数形参本体的值。</p>
  </li>
</ul>

<blockquote>
  <p>注意</p>

  <ul>
    <li>
      <p>不要使用未初始化的指针</p>

      <p>未初始化的指针其值是一个随机值，可能擦写数据或代码，导致程序崩溃。可以使用一个现有变量的地址初始化该指针，或者使用malloc()函数先分配内存。</p>
    </li>
  </ul>
</blockquote>

<h3 id="对形参使用const">对形参使用const</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">const</code>会高速编译器，该函数不能修改arr指向的数组的内容，否则会捕获错误。</p>

<h3 id="const-的其他内容">const 的其他内容</h3>

<ul>
  <li>
    <p>把const数据或非const数据的地址初始化位指向const的指针或为其赋值是合法的。</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">rates</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">.</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">.</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">.</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">.</span><span class="mi">5</span><span class="p">};</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">locked</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">};</span>
<span class="k">const</span> <span class="kt">double</span> <span class="o">*</span> <span class="n">pc</span> <span class="o">=</span> <span class="n">rates</span><span class="p">;</span>
<span class="n">pc</span> <span class="o">=</span> <span class="n">locked</span><span class="p">;</span>
<span class="n">pc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rates</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  
</code></pre></div>    </div>
  </li>
  <li>
    <p>只能把非const数据的地址赋给普通指针：</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">rates</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">.</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">.</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">.</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">.</span><span class="mi">5</span><span class="p">};</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">locked</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="p">};</span>
<span class="kt">double</span> <span class="o">*</span> <span class="n">pc</span> <span class="o">=</span> <span class="n">rates</span><span class="p">;</span>
<span class="n">pc</span> <span class="o">=</span> <span class="n">locked</span><span class="p">;</span>  <span class="c1">// 在我的win10上，gcc 8.1, 此处警告，能运行</span>
<span class="o">*</span><span class="n">pc</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>     <span class="c1">// 此处成功改变了const数组的取值</span>
<span class="n">pc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rates</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  
</code></pre></div>    </div>
  </li>
  <li>
    <p>const与 *位置的细节</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1  const type *</span>
<span class="k">const</span> <span class="kt">double</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">rates</span><span class="p">;</span>  <span class="c1">// 可以修改p指向的地址，但是无法修改该地址上的值。</span>
  
<span class="c1">// 2 type const * </span>
<span class="kt">double</span> <span class="k">const</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">rates</span><span class="p">;</span>  <span class="c1">// 可以修改指针，但是无法修改取值。</span>
  
<span class="c1">// 3 type * const p </span>
<span class="kt">double</span> <span class="o">*</span> <span class="k">const</span> <span class="n">p</span> <span class="o">=</span> <span class="n">rates</span><span class="p">;</span>  <span class="c1">// 无法修改p指向的地址，但是可以修改该地址上的值</span>
  
</code></pre></div>    </div>

    <p>奇怪的是，编译时抛出异常了，但是调试的时候并没有中断（VScode gcc 8.1）</p>
  </li>
</ul>

<h2 id="指针和多维数组">指针和多维数组</h2>

<p>示例：<code class="language-plaintext highlighter-rouge">int zippo[4][2]; // 内涵int数组的数组</code></p>

<p><code class="language-plaintext highlighter-rouge">zippo</code>的首元素是一个内涵两个int值的数组，所以zippo时这个内含两个int 值得数组得地址。</p>

<ul>
  <li>因为<code class="language-plaintext highlighter-rouge">zippo</code>是数组首元素的地址，所以<code class="language-plaintext highlighter-rouge">zippo</code>的值和<code class="language-plaintext highlighter-rouge">&amp;zippo[0]</code>的值相同。
    <ul>
      <li><code class="language-plaintext highlighter-rouge">zippo[0]</code>本身是一个内含两个帧数的数组，所以<code class="language-plaintext highlighter-rouge">zippo[0]</code>的值和它首元素（一个整数）的地址(<code class="language-plaintext highlighter-rouge">&amp;zippo[0][0]</code>)相同。</li>
      <li><code class="language-plaintext highlighter-rouge">zippo[0]</code>是一个占用一个int大学奥对象的地址，而<code class="language-plaintext highlighter-rouge">zippo</code>是一个占用两个int大小对象的地址。由于这个整数和内含两个整数的数组都开始与同一个地址，所以<code class="language-plaintext highlighter-rouge">zippo</code>和<code class="language-plaintext highlighter-rouge">zippo[0]</code>的值相同。</li>
    </ul>
  </li>
</ul>

<p>[ 长度 ]:</p>

<h1 id="扩展">扩展</h1>

<blockquote>
  <p><a href="https://tjumyk.github.io/sdl-tutorial-cn/contents.html">目录 · SDL中文教程 (tjumyk.github.io)</a></p>
</blockquote>
:ET